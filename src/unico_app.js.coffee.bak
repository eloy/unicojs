id_counter = 0
newID = ->
  id_counter += 1

class UnicoContext
  constructor: (@app, @ctrl, @scope=false, @opt={}) ->
    @keys = []
    @values = []
    @_watchExpressions = {}
    @_changeListeners = []
    @_childsScopes = []


  # Return a new evalutor with a copy of this, plus the given scope.
  # Used for each loops
  child: (scope, opt={}) ->
    childEv = new UnicoContext @app, @ctrl, scope, opt
    @_childsScopes.push childEv
    childEv

  interpolate: (html) ->
    html.replace /{{([\s\w\d\[\]_\(\)\.\$"']+)}}/g, (match, capture) =>
      @eval capture

  eval: (expression) ->
    @_extractParams(@ctrl)
    @_extractParams(@scope) if @scope

    try
      # Execute expression
      cmd = "return #{expression};"
      args = @keys.concat [cmd]
      func = Function(@keys, cmd)
      value = func.apply(@ctrl, @values)
      return value
    catch error
      console.error error.stack
      return ""

  # Create callbacks attached to React elements at render time
  buildCallbacks: (attrs) ->
    if attrs['click']
      attrs['onClick'] = =>
        ret = @eval attrs['click']
        @_digest()
        return ret


  # Inspect the node for directives at inspection time
  buildNode: (node) ->
    if node.content? && @watch node.content
      # At this point, we break the conten into an array of strings
      # and object, so "ola {{ke}} ase" will be transformed to ["ola
      # ", exp_id, " ase"]
      if @opt.repeat
        node.interpolate = true
      else
        node.interpolate = @_splitInterpolated node.content

    @_attachDirectives node
    node



  # Check if the given string contains expressions. If so, store that
  # expressions for digest and return true. Return false if not
  # expression found
  watch: (str) ->
    str.match(/{{.+}}/) != null


  props: ->
    p = {}
    for exp, data of @_watchExpressions
      # Cache last value for digest later
      data.value = @eval(exp)
      p[data.property] = data.value
    return p

  propertyId: (exp) ->
    if @opt.repeat
      exp = @_watchExpressions[exp]
      return false unless exp
    else
      exp = @_watchExpressions[exp] ||= { property: newID() }
    exp.property


  changed:  ->
    @_triggerChange()

  _digest: ->
    @_triggerChange() if @_hasChanged()

  # Return true if some value change Whenever the view evaluate an
  # expression, we store the returned value.  With this function we
  # evaluate every expression in this context or childrens and return
  # true as soon as we found a diffrence
  _hasChanged: ->
    for exp, old of @_watchExpressions
      newValue = @ctxalexp
      return true if newValue != old
    for c in @_childsScopes
      return true if c.changed()
    return false

  addChangeListener: (callback) ->
    @_changeListeners.push callback

  _generateID: ->
    @counter ||= 0
    @counter += 1

  _extractParams: (ctx) ->
    for k, v of ctx
      @keys.push k
      if typeof(v) == "function"
        @values.push @_buildFunctionProxy k, v, @ctrl
      else
        @values.push v

  # Create functions used in the evaluator.
  # Simplify sintax and emulate functions called in the controller scope
  # By example, we can use foo() and it will execute ctrl.foo()
  _buildFunctionProxy: (k, v, ctrl) ->
    () -> v.apply ctrl, arguments

  # Send an event to listeners with a change notification
  _triggerChange: ->
    for callback in @_changeListeners
      callback()

  # Search for directives and initialize'em at inspection time
  _attachDirectives: (node) ->
    for key, value of node.attrs
      if @app.directives[key]?
        node.directives ||= []
        node.directives.push(new @app.directives[key]())

    # If node has no directives, we are done
    return false unless node.directives?

    node.attrs['key'] ||= @_generateID()
    # Init directives if init present
    for d in node.directives
      d.init(@, node) if d.init?

    return true


  _splitInterpolated: (content) ->
    childs = []
    lastPos = 0
    content.replace /{{([\s\w\d\[\]_\(\)\.\$"']+)}}/g, (match, capture, pos) =>
      if pos > lastPos
        childs.push {t: "text", v: content.substr(lastPos, pos - lastPos)}

      # Update lastPos
      lastPos = pos + match.length
      childs.push {t: "exp", v: capture, property: @propertyId(capture)}

    childs

extractAttributes = (el) ->
  attrs = {}
  return attrs unless el.attributes and el.attributes.length > 0
  length = el.attributes.length - 1
  for i in [0..length]
    key = el.attributes[i].name
    value = el.attributes[i].value

    # Do some transformations for react
    key = "className" if key == "class"

    # Assign the value
    attrs[key] = value

  return attrs

dom2nodes = (el, ctx) ->
  nodes = []
  for child in el.contents()
    tagName = $(child).prop('tagName')?.toLowerCase()
    attrs = extractAttributes(child)

    if tagName && attrs.repeat?
      exp = attrs.repeat.match(/([\w\d_\$]+)\s?,?\s?([\w\d_\$]+)?\s+in\s+([\s\w\d\[\]_\(\)\.\$"']+)/)
      keyName = exp[1]
      valueName = exp[2]
      collectionExpression = exp[3]
      childCtx = ctx.child({}, repeat: true)
      childNodes = dom2nodes $(child), childCtx
      nodes.push ctx.buildNode(tag: tagName, attrs: attrs, nodes: childNodes, repeat: {keyName: keyName, valueName: valueName, collectionExpression: collectionExpression})

    # If node has childs, deep into
    else if tagName && $(child).children().length > 0
      childNodes = dom2nodes $(child), ctx
      nodes.push ctx.buildNode(tag: tagName, attrs: attrs, nodes: childNodes)
    else
      if tagName
        value = $(child).val() || $(child).html()
        nodes.push ctx.buildNode(tag: tagName, attrs: attrs, content: value )
      else
        value = child.textContent
        if value.trim().length > 0
          nodes.push ctx.buildNode content: value

  return nodes

interpolate2react = (interpolate, reactClass) ->
  r = []
  for i in interpolate
    if i.t == 'text'
      r.push i.v
    else
      r.push reactClass.props[i.property]
  return r


buildReactDOM = (ctx, node, content) ->
  if node.directives?
    d.build(ctx, node) for d in node.directives when d.build


  dom = React.DOM[node.tag] node.attrs, content
  window.dom = dom
  return dom unless node.directives?

  renderCallback = -> dom
  mountCallback = ->
    el = this.getDOMNode()
    for d in node.directives when d.link && !d._linked
      d._linked = true
      d.link(ctx, el, node, @)
  reactHelpers = node.reactHelpers || {}
  reactHelpers.render = renderCallback
  reactHelpers.componentDidMount =  mountCallback
  componentClass = React.createClass(reactHelpers)

  componentClass()

# Creates React elements from our tree
#----------------------------------------------------------------------
nodes2react = (nodes, ctx, reactClass,opt={}) ->
  el = []
  for node in nodes

    # Build callbacks
    unless node.repeat?
      ctx.buildCallbacks node.attrs if node.attrs

    if node.repeat?
      collection = ctx.eval node.repeat.collectionExpression
      reactClass = React.createClass repeat: true, render: ->
        childs = []
        if @props.data instanceof Array
          for item in @props.data
            scope = {}
            scope[node.repeat.keyName] = item
            childCtx = ctx.child(scope)

            childs.push nodes2react node.nodes, childCtx, @, interpolate: true
            # build callbacks with the childcontext
        ctx.buildCallbacks node.attrs if node.attrs
        buildReactDOM ctx, node, childs

      el.push (new reactClass(data: collection))
    # Node with childrens
    else if node.nodes && node.nodes.length > 0
      reactNodes = nodes2react node.nodes, ctx, reactClass, opt
      el.push buildReactDOM ctx, node, reactNodes

    # Node without childrens
    else if node.tag
      if node.interpolate?
        if opt.interpolate
          value = ctx.interpolate(node.content)
        else
          value = interpolate2react node.interpolate, reactClass
      else
        value = node.content
      el.push buildReactDOM ctx, node, value

    # Text Node
    else if node.content?
      if node.interpolate?
        if opt.interpolate
          value = ctx.interpolate(node.content)
        else
          value = interpolate2react node.interpolate, reactClass
      else
        value = node.content
      el.push value
  return el

class UnicoInstance
  constructor: (@app, @ctrl, @el) ->
    @ctx = new UnicoContext(@app, @ctrl)
    @html = @el.html()
    @rootNode = @parseDOM()
    @translate()
    @ctx.addChangeListener => @refresh()
    @refresh()

  refresh: ->
    @reactRender.setProps @ctx.props()
    return true

  translate: ->
    # TODO: check if root is text
    root = @rootNode
    ctx = @ctx
    @reactClass = React.createClass displayName: "Version", render: ->
      nodes = nodes2react root.nodes, ctx, @
      elements = [root.attrs].concat nodes
      React.DOM[root.tag].apply(null, elements)
    @reactRender = React.renderComponent @reactClass(@ctx.props()), @el[0]

  parseDOM: ->
    tagName = @el.prop('tagName').toLowerCase()
    attrs = extractAttributes(@el)
    nodes = dom2nodes(@el, @ctx)
    { tag: tagName, attrs: attrs, nodes: nodes }


# built in directives
#----------------------------------------------------------------------

class ModelDirective
  build: (ctx, node) ->
    @propertyId = ctx.propertyId(node.attrs.model)

  link: (scope, el, node, reactElement) ->
    # node.attrs.value = scope.eval node.attrs.model
    # node.attrs.onChange = (e) ->
    #   value = e.target.value
    #   value = "'#{value}'" unless typeof(n) == "number"
    #   exp = "this.#{node.attrs.model} = #{value};"
    #   scope.eval exp

    #   console.log value
    console.log node.attrs
    node.attrs.valueLink = {
      value: scope.eval(node.attrs.model)
      requestChange: (v) ->
        @value = v
        value = v
        value = "'#{value}'" unless typeof(n) == "number"
        exp = "this.#{node.attrs.model} = #{value};"
        scope.eval exp
        scope.changed()
        return true
    }

# Main app
#----------------------------------------------------------------------

class UnicoApp
  constructor: ->
    @controllers = {}
    @directives = {model: ModelDirective}

  addController: (name, clazz) ->
    @controllers[name] = clazz

  addDirective: (name, clazz) ->
    @directives[name] = clazz

  render: ->
    @instances = []
    # Search for controllers
    for el in $("[controller]")
      name = $(el).attr 'controller'
      clazz = @controllers[name]
      ctrl = new clazz()
      @instances.push new UnicoInstance @, ctrl, $(el)
  refresh: ->
    for instance in @instances
      instance.refresh()
    true
window.UnicoApp = UnicoApp
